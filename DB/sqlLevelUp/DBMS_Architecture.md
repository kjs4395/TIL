## SQL 레벨업 (2019.03.11.월)

# DBMS 아키텍쳐
* 쿼리 평가 엔진
	*  SQL 구문 분석 후 실행계획, 접근 메서드 결정
* 버퍼매니저
   * 메모리 영역 확보
* 디스크용량 매니저
   * 어디에 어떻게 데이터를 저장할지 관리한다. 데이터 읽고, 쓰기 관리
* 트랜잭션 매니저 & 락매니저
	* 여러 사람 사용시 트렌젝션 단위로 관리.
* 리커버리 매니저
	* 장애 발생시 복구를 위해 정기적 백업 및 복구를 담당 

	
# DBMS와 버퍼
* 기억 장치의 종류
   * 1차 기억장치 : 레지스터, 메모리
   * 2차 기억장치 : HDD, CD, DVD, 플래시 메모리
   * 3차 기억장치 : 테이프
    
기억비용    높음  <---------------------> 낮음    

접근속도    빠름  <---------------------> 느림

1차 기억장치 <-----------------------> 3차 기억장치 
     
결론 : 3차 기억장치로 갈수록 용량대비 비용은 저렴하지만 접근 속도가 너무 느려 트레이드 오프가 발생한다!.

* DBMS와 기억 장치의 관계
 	* 하드디스크(HDD)
 		* DBMS가 데이터를 저장하는 매체. (2차 기억장치) 
 		* 장점도 단점도 없는 무난한 매체
 	* 메모리
 		* 디스크에 비해 기억비용이 비싸다. (1차 기억장치)
 		* 일부 데이터를 메모리에 올려놓는다. (자주 접근하는 데이터)
	* 버퍼를 활용한 속도 향상 (버퍼 || 캐시)
		*  사용자와 데이터 사이에서 데이터 전송 지연을 완화.
		*  고속 접근이 가능한 버퍼에 데이터를 어떻게 어느정도의 기간동안 올릴지를 결정

* 메모리 위에 있는 버퍼 종류
	* 데이터 캐시
		* 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역. 
	* 로그 버퍼 
		* 갱신처리와 관련.(INSERT, UPDATE, DELETE, MERGE)
		* 데이터 갱신이 일어나면 로그 버퍼 -> 디스크 변경 순으로 수행.(비동기)
* 메모리의 휘발성 (가격제외한 메모리의 단점)
	* 영속성이 없어 장애가 발생했을때 데이터 부정합 문제가 발생할 수 있다.
	* 해결책
		*  DBMS는 커밋 시점(갱신 처리를 확정)에 반드시 갱신 정보를 로그파일(영속성 저장소)위에 씀으로써 정합성 보장.
		*  커밋 때에는 반드시 디스크 동기 접근!
* 데이터 캐시와 로그 버퍼의 크기
	* default 초기 값 데이터 캐시 (검색) >>>>>>>>> 로그 버퍼 (갱신)
		* why ? 검색을 메인으로 처리한다고 가정하기 때문.
* 추가적 메모리 영역 = 워킹 메모리
	* 정렬 또는 해시 관련 처리에 사용. (ORDER BY, 테이블 JOIN)	* 처리에 사용되고 종료되면 임시해지.
	* 만약 이 영역이 부족하다면...?
		* 대부분의 DBMS가 저장소를 사용해 전체적인 속도 감소!	
		
		  
		
				
		
 		